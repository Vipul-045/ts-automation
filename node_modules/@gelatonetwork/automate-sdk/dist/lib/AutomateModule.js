"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutomateModule = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
/* eslint-disable no-empty */
const ethers_1 = require("ethers");
const types_1 = require("../types");
const Web3FunctionDownloader_1 = require("./Web3Function/Web3FunctionDownloader");
class AutomateModule {
    constructor() {
        this.encodeModuleArgs = (moduleArgsParams) => __awaiter(this, void 0, void 0, function* () {
            const modules = [];
            const args = [];
            const { resolverAddress, resolverData, dedicatedMsgSender, singleExec, web3FunctionHash, web3FunctionArgs, web3FunctionArgsHex, trigger, } = moduleArgsParams;
            if (resolverAddress && resolverData) {
                modules.push(types_1.Module.RESOLVER);
                args.push(this.encodeResolverArgs(resolverAddress, resolverData));
            }
            if (dedicatedMsgSender) {
                modules.push(types_1.Module.PROXY);
                args.push("0x");
            }
            if (singleExec) {
                modules.push(types_1.Module.SINGLE_EXEC);
                args.push("0x");
            }
            if (web3FunctionHash && web3FunctionArgsHex) {
                modules.push(types_1.Module.WEB3_FUNCTION);
                args.push(yield this.encodeWeb3FunctionArgs(web3FunctionHash, undefined, web3FunctionArgsHex));
            }
            else if (web3FunctionHash && web3FunctionArgs) {
                modules.push(types_1.Module.WEB3_FUNCTION);
                args.push(yield this.encodeWeb3FunctionArgs(web3FunctionHash, web3FunctionArgs));
            }
            if (trigger) {
                modules.push(types_1.Module.TRIGGER);
                args.push(yield this.encodeTriggerArgs(trigger));
            }
            return { modules, args };
        });
        this.decodeModuleArgs = (moduleData) => __awaiter(this, void 0, void 0, function* () {
            const modules = moduleData.modules;
            const args = moduleData.args;
            const moduleArgsDecoded = {
                resolverAddress: null,
                resolverData: null,
                dedicatedMsgSender: false,
                singleExec: false,
                web3FunctionHash: null,
                web3FunctionArgs: null,
                web3FunctionArgsHex: null,
                trigger: null,
            };
            if (modules.includes(types_1.Module.RESOLVER)) {
                const indexOfModule = modules.indexOf(types_1.Module.RESOLVER);
                const { resolverAddress, resolverData } = this.decodeResolverArgs(args[indexOfModule]);
                moduleArgsDecoded.resolverAddress = resolverAddress;
                moduleArgsDecoded.resolverData = resolverData;
            }
            if (modules.includes(types_1.Module.PROXY)) {
                moduleArgsDecoded.dedicatedMsgSender = true;
            }
            if (modules.includes(types_1.Module.SINGLE_EXEC)) {
                moduleArgsDecoded.singleExec = true;
            }
            if (modules.includes(types_1.Module.WEB3_FUNCTION)) {
                const indexOfModule = modules.indexOf(types_1.Module.WEB3_FUNCTION);
                const { web3FunctionHash, web3FunctionArgs, web3FunctionArgsHex, web3FunctionSchema, } = yield this.decodeWeb3FunctionArgs(args[indexOfModule]);
                moduleArgsDecoded.web3FunctionHash = web3FunctionHash;
                moduleArgsDecoded.web3FunctionArgs = web3FunctionArgs;
                moduleArgsDecoded.web3FunctionArgsHex = web3FunctionArgsHex;
                moduleArgsDecoded.web3FunctionSchema = web3FunctionSchema;
            }
            if (modules.includes(types_1.Module.TRIGGER)) {
                const indexOfModule = modules.indexOf(types_1.Module.TRIGGER);
                const { trigger } = yield this.decodeTriggerArgs(args[indexOfModule]);
                moduleArgsDecoded.trigger = trigger;
            }
            return moduleArgsDecoded;
        });
        this.encodeResolverArgs = (resolverAddress, resolverData) => {
            const encoded = ethers_1.ethers.utils.defaultAbiCoder.encode(["address", "bytes"], [resolverAddress, resolverData]);
            return encoded;
        };
        this.decodeResolverArgs = (encodedModuleArgs) => {
            let resolverAddress = null;
            let resolverData = null;
            try {
                [resolverAddress, resolverData] = ethers_1.ethers.utils.defaultAbiCoder.decode(["address", "bytes"], encodedModuleArgs);
            }
            catch (_a) { }
            return { resolverAddress, resolverData };
        };
        this.encodeWeb3FunctionArgs = (web3FunctionHash, web3FunctionArgs, web3FunctionArgsHex) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (!web3FunctionArgsHex && web3FunctionArgs) {
                    const { types, keys } = yield this.getAbiTypesAndKeysFromSchema(web3FunctionHash);
                    // ensure all userArgs are provided & encoded in same order as they are defined in the schema
                    const values = [];
                    for (const key of keys) {
                        if (typeof web3FunctionArgs[key] === "undefined") {
                            throw new Error(`Missing user arg '${key}' defined in resolver schema`);
                        }
                        values.push(web3FunctionArgs[key]);
                    }
                    web3FunctionArgsHex = ethers_1.ethers.utils.defaultAbiCoder.encode(types, values);
                }
                const encoded = ethers_1.ethers.utils.defaultAbiCoder.encode(["string", "bytes"], [web3FunctionHash, web3FunctionArgsHex]);
                return encoded;
            }
            catch (err) {
                throw new Error(`Fail to encode Web3Function: ${err.message}`);
            }
        });
        this.decodeWeb3FunctionArgs = (encodedModuleArgs) => __awaiter(this, void 0, void 0, function* () {
            let web3FunctionHash = null;
            let web3FunctionArgs = null;
            let web3FunctionArgsHex = null;
            let web3FunctionSchema;
            [web3FunctionHash, web3FunctionArgsHex] =
                ethers_1.ethers.utils.defaultAbiCoder.decode(["string", "bytes"], encodedModuleArgs);
            const res = yield this.decodeWeb3FunctionArgsHex(web3FunctionArgsHex, {
                web3FunctionHash: web3FunctionHash,
            });
            if (res) {
                web3FunctionArgs = res.web3FunctionArgs;
                web3FunctionSchema = res.schema;
            }
            return {
                web3FunctionHash,
                web3FunctionArgs,
                web3FunctionArgsHex,
                web3FunctionSchema,
            };
        });
        this.encodeTriggerArgs = (trigger) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            let triggerArgs;
            if (trigger.type === types_1.TriggerType.TIME) {
                const triggerBytes = ethers_1.ethers.utils.defaultAbiCoder.encode(["uint128", "uint128"], [(_a = trigger.start) !== null && _a !== void 0 ? _a : 0, trigger.interval]);
                triggerArgs = ethers_1.ethers.utils.defaultAbiCoder.encode(["uint128", "bytes"], [Number(types_1.TriggerType.TIME), triggerBytes]);
            }
            else if (trigger.type === types_1.TriggerType.CRON) {
                const triggerBytes = ethers_1.ethers.utils.defaultAbiCoder.encode(["string"], [trigger.cron]);
                triggerArgs = ethers_1.ethers.utils.defaultAbiCoder.encode(["uint8", "bytes"], [Number(types_1.TriggerType.CRON), triggerBytes]);
            }
            else if (trigger.type === types_1.TriggerType.EVENT) {
                const triggerBytes = ethers_1.ethers.utils.defaultAbiCoder.encode(["address", "bytes32[][]", "uint256"], [
                    trigger.filter.address,
                    trigger.filter.topics,
                    trigger.blockConfirmations,
                ]);
                triggerArgs = ethers_1.ethers.utils.defaultAbiCoder.encode(["uint8", "bytes"], [Number(types_1.TriggerType.EVENT), triggerBytes]);
            }
            else {
                const triggerBytes = ethers_1.ethers.utils.defaultAbiCoder.encode(["bytes"], ["0x"]);
                triggerArgs = ethers_1.ethers.utils.defaultAbiCoder.encode(["uint8", "bytes"], [Number(types_1.TriggerType.BLOCK), triggerBytes]);
            }
            return triggerArgs;
        });
        this.decodeTriggerArgs = (encodedModuleArgs) => __awaiter(this, void 0, void 0, function* () {
            let type = null;
            let encodedTriggerConfig = null;
            let trigger = null;
            try {
                [type, encodedTriggerConfig] = ethers_1.ethers.utils.defaultAbiCoder.decode(["uint8", "bytes"], encodedModuleArgs);
                if (type !== null && encodedTriggerConfig !== null) {
                    if (type === types_1.TriggerType.TIME) {
                        let [start, interval] = ethers_1.ethers.utils.defaultAbiCoder.decode(["uint128", "uint128"], encodedTriggerConfig);
                        if (start !== null && interval !== null) {
                            if (typeof start === "object" && start instanceof ethers_1.BigNumber) {
                                start = start.toNumber();
                            }
                            if (typeof interval === "object" && interval instanceof ethers_1.BigNumber) {
                                interval = interval.toNumber();
                            }
                            trigger = { type, start, interval };
                        }
                    }
                    else if (type === types_1.TriggerType.CRON) {
                        const [cron] = ethers_1.ethers.utils.defaultAbiCoder.decode(["string"], encodedTriggerConfig);
                        if (cron !== null) {
                            trigger = { type, cron };
                        }
                    }
                    else if (type === types_1.TriggerType.EVENT) {
                        const [address, topics, blockConfirmations] = ethers_1.ethers.utils.defaultAbiCoder.decode(["address", "bytes32[][]", "uint256"], encodedTriggerConfig);
                        if (address !== null &&
                            topics !== null &&
                            blockConfirmations !== null) {
                            trigger = {
                                type,
                                filter: { address, topics },
                                blockConfirmations: blockConfirmations.toNumber(),
                            };
                        }
                    }
                    else if (type === types_1.TriggerType.BLOCK) {
                        trigger = { type };
                    }
                }
            }
            catch (_b) { }
            return { trigger };
        });
        this.decodeWeb3FunctionArgsHex = (web3FunctionArgsHex, schemaOption) => __awaiter(this, void 0, void 0, function* () {
            try {
                let schemaAbi;
                const web3FunctionArgs = {};
                if (schemaOption.web3FunctionHash)
                    schemaAbi = yield this.getAbiTypesAndKeysFromSchema(schemaOption.web3FunctionHash);
                else
                    schemaAbi = yield this.getAbiTypesAndKeysFromSchema(undefined, schemaOption.userArgsSchema);
                const { types, keys, schema } = schemaAbi;
                const web3FunctionArgsValues = ethers_1.ethers.utils.defaultAbiCoder.decode(types, web3FunctionArgsHex);
                // decode argument according to schema key order
                keys.forEach((key, idx) => {
                    let val = web3FunctionArgsValues[idx];
                    // Transform BigNumber[] in number[]
                    if (Array.isArray(val)) {
                        val = val.map((v) => {
                            if (typeof v === "object" && v instanceof ethers_1.BigNumber) {
                                return v.toNumber();
                            }
                            return v;
                        });
                        // Transform BigNumber in number
                    }
                    else if (typeof val === "object" && val instanceof ethers_1.BigNumber) {
                        val = val.toNumber();
                    }
                    web3FunctionArgs[key] = val;
                });
                return { web3FunctionArgs, schema };
            }
            catch (err) {
                return null;
            }
        });
        this.getAbiTypesAndKeysFromSchema = (web3FunctionHash, _userArgsSchema) => __awaiter(this, void 0, void 0, function* () {
            try {
                let userArgsSchema = _userArgsSchema;
                let schema;
                if (!userArgsSchema) {
                    if (web3FunctionHash) {
                        const downloader = new Web3FunctionDownloader_1.Web3FunctionDownloader();
                        schema = yield downloader.fetchSchema(web3FunctionHash);
                        userArgsSchema = schema.userArgs;
                    }
                    else
                        throw new Error(`Both userArgsSchema && web3FunctionHash undefined`);
                }
                const types = [];
                const keys = [];
                Object.keys(userArgsSchema).forEach((key) => {
                    if (!userArgsSchema || !userArgsSchema[key])
                        return;
                    keys.push(key);
                    const value = userArgsSchema[key];
                    switch (value) {
                        case "number":
                            types.push("uint256");
                            break;
                        case "string":
                            types.push("string");
                            break;
                        case "boolean":
                            types.push("bool");
                            break;
                        case "number[]":
                            types.push("uint256[]");
                            break;
                        case "string[]":
                            types.push("string[]");
                            break;
                        case "boolean[]":
                            types.push("bool[]");
                            break;
                        default:
                            throw new Error(`Invalid schema in web3Function CID: ${web3FunctionHash}. Invalid type ${value}. userArgsSchema: ${userArgsSchema}`);
                    }
                });
                return { types, keys, schema };
            }
            catch (err) {
                throw new Error(`Fail to get types from schema: ${err.message}`);
            }
        });
    }
}
exports.AutomateModule = AutomateModule;
