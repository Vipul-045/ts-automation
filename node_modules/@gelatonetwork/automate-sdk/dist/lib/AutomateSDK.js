"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutomateSDK = void 0;
/* eslint-disable no-prototype-builtins */
require("ethers");
const abstract_signer_1 = require("@ethersproject/abstract-signer");
const axios_1 = __importDefault(require("axios"));
const ethers_1 = require("ethers");
const constants_1 = require("../constants");
const types_1 = require("../contracts/types");
const Module_interface_1 = require("../types/Module.interface");
const utils_1 = require("../utils");
const AutomateModule_1 = require("./AutomateModule");
const Signature_1 = require("./Signature");
class AutomateSDK {
    constructor(chainId, signer, automateAddress, signatureMessage, config) {
        var _a;
        /**
         * @deprecated this function will be removed in next major upgrade
         */
        this.isGnosisSafeApp = () => {
            var _a;
            let provider;
            if ((_a = this._signer.provider) === null || _a === void 0 ? void 0 : _a.hasOwnProperty("provider")) {
                // Use internal provider
                provider = this._signer.provider.provider;
            }
            else {
                provider = this._signer.provider;
            }
            return Boolean(provider === null || provider === void 0 ? void 0 : provider.hasOwnProperty("safe"));
        };
        if (!abstract_signer_1.Signer.isSigner(signer)) {
            throw new Error(`Invalid Automate signer`);
        }
        this._automateModule = new AutomateModule_1.AutomateModule();
        this._signature = new Signature_1.Signature(chainId, signer, signatureMessage, config === null || config === void 0 ? void 0 : config.signatureDomain);
        this._chainId = chainId;
        this._signer = signer;
        this._automate = types_1.Automate__factory.connect(automateAddress, this._signer);
        let taskApiUrl = constants_1.AUTOMATE_TASKS_API;
        if (config) {
            taskApiUrl =
                ((_a = config.taskApi) !== null && _a !== void 0 ? _a : config.isDevelopment)
                    ? constants_1.AUTOMATE_TASKS_DEV_API
                    : constants_1.AUTOMATE_TASKS_API;
        }
        this._taskApi = axios_1.default.create({ baseURL: taskApiUrl });
    }
    static create(chainId, signer, signatureMessage, config) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const automateAddress = yield this._fetchAutomateAddress(chainId, (_a = config === null || config === void 0 ? void 0 : config.isDevelopment) !== null && _a !== void 0 ? _a : false);
            return new AutomateSDK(chainId, signer, automateAddress, signatureMessage, config);
        });
    }
    getActiveTasks(creatorAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            // Retrieve user task ids
            const address = creatorAddress !== null && creatorAddress !== void 0 ? creatorAddress : (yield this._signer.getAddress());
            const taskIds = yield this._automate.getTaskIdsByUser(address);
            // Retrieve task names
            const path = `/tasks/${this._chainId}/getTasksByTaskIds`;
            const tasksNames = yield this._postTaskApi(path, {
                taskIds,
            }, true);
            // Build results
            const tasks = [];
            for (const taskId of taskIds) {
                const taskName = tasksNames === null || tasksNames === void 0 ? void 0 : tasksNames.find((t) => t.taskId === taskId);
                tasks.push({
                    taskId,
                    name: taskName ? taskName.name : taskId,
                });
            }
            return tasks;
        });
    }
    _getDedicatedMsgSender(creatorAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const opsProxyFactory = yield this._getOpsProxyFactory();
            const [address, isDeployed] = yield opsProxyFactory.getProxyOf(creatorAddress);
            return { address, isDeployed };
        });
    }
    _getOpsProxyFactory() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._opsProxyFactory) {
                const proxyModuleAddress = yield this._automate.taskModuleAddresses(Module_interface_1.Module.PROXY);
                const opsProxyFactoryAddress = yield types_1.ProxyModule__factory.connect(proxyModuleAddress, this._signer).opsProxyFactory();
                const opsProxyFactory = types_1.AutomateProxyFactory__factory.connect(opsProxyFactoryAddress, this._signer);
                this._opsProxyFactory = opsProxyFactory;
            }
            return this._opsProxyFactory;
        });
    }
    getDedicatedMsgSender() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._getDedicatedMsgSender(yield this._signer.getAddress());
        });
    }
    getTaskId(_args, creatorAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = yield this._processModules(_args);
            return this._getTaskId(args, creatorAddress);
        });
    }
    _getTaskId(args, creatorAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = creatorAddress !== null && creatorAddress !== void 0 ? creatorAddress : (yield this._signer.getAddress());
            const modules = args.moduleData.modules;
            if ((modules.length === 1 && modules[0] === Module_interface_1.Module.RESOLVER) ||
                (modules.length === 2 &&
                    modules[0] === Module_interface_1.Module.RESOLVER &&
                    modules[1] === Module_interface_1.Module.TIME))
                return this._getLegacyTaskId(args, address);
            const taskId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.defaultAbiCoder.encode([
                "address",
                "address",
                "bytes4",
                "tuple(uint8[] modules,bytes[] args)",
                "address",
            ], [
                address,
                args.execAddress,
                args.execSelector,
                args.moduleData,
                args.useTreasury ? ethers_1.ethers.constants.AddressZero : constants_1.ETH,
            ]));
            return taskId;
        });
    }
    _getLegacyTaskId(args, creatorAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolverHash = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.defaultAbiCoder.encode(["address", "bytes"], [args.resolverAddress, args.resolverData]));
            const taskId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.defaultAbiCoder.encode(["address", "address", "bytes4", "bool", "address", "bytes32"], [
                creatorAddress,
                args.execAddress,
                args.execSelector,
                args.useTreasury,
                args.useTreasury ? ethers_1.ethers.constants.AddressZero : constants_1.ETH,
                resolverHash,
            ]));
            return taskId;
        });
    }
    _prepareBatchCreateTaskOptions(_args, creatorAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            creatorAddress = creatorAddress !== null && creatorAddress !== void 0 ? creatorAddress : (yield this._signer.getAddress());
            const { address: execAddress } = yield this._getDedicatedMsgSender(creatorAddress);
            const automateProxyInterface = types_1.AutomateProxy__factory.createInterface();
            const execSelector = automateProxyInterface.getSighash("batchExecuteCall");
            const execAbi = automateProxyInterface.format("json");
            const createTaskOptions = Object.assign(Object.assign({}, _args), { execAddress,
                execSelector,
                execAbi, dedicatedMsgSender: true });
            return createTaskOptions;
        });
    }
    prepareBatchExecTask(args, overrides = {}, creatorAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = yield this._prepareBatchCreateTaskOptions(args, creatorAddress);
            return yield this.prepareTask(options, overrides, creatorAddress);
        });
    }
    createBatchExecTask(args, overrides = {}, authToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const createTaskOptions = yield this._prepareBatchCreateTaskOptions(args);
            return yield this.createTask(createTaskOptions, overrides, authToken);
        });
    }
    prepareTask(_args, overrides = {}, creatorAddress) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const args = yield this._processModules(_args);
            const tx = yield this._automate.populateTransaction.createTask(args.execAddress, (_a = args.execData) !== null && _a !== void 0 ? _a : args.execSelector, args.moduleData, args.useTreasury ? constants_1.ZERO_ADD : constants_1.ETH, overrides);
            const taskId = yield this._getTaskId(args, creatorAddress);
            return { taskId, tx, args };
        });
    }
    createTask(_args, overrides = {}, authToken) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ask for signature
            if (!authToken)
                authToken = yield this._signature.getAuthToken();
            const { taskId, args, tx: unsignedTx, } = yield this.prepareTask(_args, overrides);
            const tx = yield this._signer.sendTransaction(unsignedTx);
            yield this._finalizeTaskCreation(taskId, args, authToken);
            return { taskId, tx };
        });
    }
    _processModules(args) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const moduleData = yield this._automateModule.encodeModuleArgs({
                resolverAddress: args.resolverAddress,
                resolverData: args.resolverData,
                dedicatedMsgSender: args.dedicatedMsgSender,
                singleExec: args.singleExec,
                web3FunctionHash: args.web3FunctionHash,
                web3FunctionArgs: args.web3FunctionArgs,
                web3FunctionArgsHex: args.web3FunctionArgsHex,
                trigger: args.trigger,
            });
            return Object.assign(Object.assign({}, args), { useTreasury: (_a = args.useTreasury) !== null && _a !== void 0 ? _a : true, moduleData });
        });
    }
    _finalizeTaskCreation(taskId, args, authToken) {
        return __awaiter(this, void 0, void 0, function* () {
            // Post task name & contracts ABI to tasks API
            const { name, execAddress, execAbi, resolverAddress, resolverAbi } = args;
            const promises = [];
            promises.push(this._setTaskName(taskId, name !== null && name !== void 0 ? name : taskId, authToken));
            if (execAbi) {
                promises.push(this._setContractAbi(taskId, false, execAddress, execAbi, authToken));
            }
            if (resolverAddress && resolverAbi) {
                promises.push(this._setContractAbi(taskId, true, resolverAddress, resolverAbi, authToken));
            }
            yield Promise.all(promises);
        });
    }
    prepareCancelTask(taskId, overrides = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this._automate.populateTransaction.cancelTask(taskId, overrides);
            return { taskId, tx };
        });
    }
    cancelTask(taskId, overrides = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { tx: unsignedTx } = yield this.prepareCancelTask(taskId, overrides);
            const tx = yield this._signer.sendTransaction(unsignedTx);
            return { taskId, tx };
        });
    }
    _setTaskName(taskId, name, authToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = `/tasks/${this._chainId}`;
            yield this._postTaskApi(path, { taskId, name, chainId: this._chainId }, false, authToken);
        });
    }
    renameTask(taskId, name, authToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = `/tasks/${this._chainId}/${taskId}`;
            yield this._postTaskApi(path, { name }, false, authToken);
        });
    }
    _setContractAbi(taskId, isResolver, address, abi, authToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = `/contracts/${this._chainId}/`;
            yield this._postTaskApi(path, {
                chainId: this._chainId,
                taskId,
                address,
                resolver: isResolver,
                ABI: abi,
            }, false, authToken);
        });
    }
    _postTaskApi(path, data, skipSignature = false, authToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = {};
            if (!skipSignature) {
                if (!authToken)
                    authToken = yield this._signature.getAuthToken();
                headers["Authorization"] = `Bearer ${authToken}`;
            }
            try {
                const response = yield this._taskApi.post(`${path}`, data, { headers });
                return response.data;
            }
            catch (err) {
                const errMsg = (0, utils_1.errorMessage)(err);
                console.error(`Error naming task for task ${data.taskId}. \n${errMsg}`);
                return undefined;
            }
        });
    }
    static _fetchAutomateAddress(chainId, isDevelopment) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const apiUrl = isDevelopment ? constants_1.AUTOMATE_W3F_DEV_API : constants_1.AUTOMATE_W3F_API;
                const response = yield axios_1.default.get(`${apiUrl}/networks/${chainId}`);
                const automateAddress = response.data.network.automate;
                return automateAddress;
            }
            catch (err) {
                const errMsg = (0, utils_1.errorMessage)(err);
                console.error(`Error fetching automate address for chainId: ${chainId}. \n${errMsg}`);
                throw new Error(`Error fetching automate address for chainId: ${chainId}. \n${errMsg}`);
            }
        });
    }
}
exports.AutomateSDK = AutomateSDK;
